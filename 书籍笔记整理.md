#	《深入浅出Vue.js》

# 第一篇 变化侦测
* 变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。


##	第2章	Object的变化侦测
Object和Array的变化侦测采用不同的处理方式。

###	2.1	什么是变化侦测
*	Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫**渲染**。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。
*	Vue.js能随意调整粒度，本质上要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

###	2.2 如何追踪变化
*	在JavaScript中，有两种方法可以侦测到变化：使用Object.defineProperty 和 ES6的Proxy。
*	到目前为止，Vue.js还是使用的**Object.defineProperty**来实现的。

###	2.3 如何手机依赖
*	**注意：**在Vue.js2.0中，模板使用数据等同于组件使用数据，所有当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。
*	在getter中手机依赖，在setter中触发依赖。

###	2.4 依赖收集在哪里
*	



##
##	第3章	Array的变化侦测
###	3.1	如何追踪变化
*	我们可以用一个拦截器覆盖Array.prototype。之后，每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后，在拦截器中使用原生Array的原型方法去操作数组。
*	这样通过拦截器，我们就可以追踪到Array的变化。

###	3.2	拦截器
*	Array原型中可以改变数组自身内容的方法有7个，分别是push、pop、shift、unshift、splice、sort和reverse。

###	3.3	使用拦截器覆盖Array原型

###	3.4	将拦截器方法挂载到数组的属性上

###	3.5	如何收集依赖
*	Array在getter中收集依赖，在拦截器中触发依赖。

###	3.6	依赖列表存在哪儿
*	Vue.js把	Array的依赖存放在Observer中。

###	3.7	收集依赖

###	3.8	在拦截器中获取Observer实例

###	3.9	想数组的依赖发送通知
*	当侦测到数组发生变化时，会向依赖发送通知。


##
##	第4章	变化侦测相关的API实现原理
###	4.1	[vm.$watch](https://cn.vuejs.org/v2/api/#vm-watch)
####	4.1.1	用法
*	vm.$watch( expOrFn, callback, [options] )

*	参数：
	*	{string | Function} expOrFn
	*	{Function | Object} callback
	*	{Object} [options]
		*	{boolean} deep
		*	{boolean} immediate
*	返回值：{Function} unwatch

*	**用法：**用于观察一个表达式或computed（计算属性）函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如 a.b.c 。如果是一个比较复杂的表达式，可以用函数代替表达式。

**注意：**在变异 (不是替换) 对象或数组时，旧值将与新值相同，因
为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。

*	示例：	

*	deep。为了发现对象内部值的变化，可以在选项参数中指定deep:true。
*	注意监听数组的变动不需要这么做。
    `vm.$watch('someObject', callback, {	
		deep:true
	})
	vm.someObject.nestedValue = 123
	//回调函数将被触发`

*	immediate。在选项参数中指定immediate:true，将立即以表达式的当前值触发回调。
	`vm.$watch('a', callback, {
		immediate: true
	})
	//立即以'a'的当前值触发回调`


####	4.1.2	watch的内部原理
*	vm.$watch其实是对Watcher的一种封装。通过Watcher完全可以实现vm.$watch的功能，但是vm.$watch中的参数deep和immediate是Watcher中所没有的。

####	4.1.3	deep参数中的实现原理

###	4.2	[vm.$set](https://cn.vuejs.org/v2/api/#vm-set)
####	4.2.1	用法
*	vm.$set( target, key, value )

*	参数：
	*	{Object | Array} target
	*	{string | number} propertyName/index
	*	{any} value

*	返回值：{Function} unwatch

*	**用法：**在object上设置一个属性，如果object是响应式的，Vue.js会保证属性被创建后也是响应式的，而且触发试图更新。这个方法主要用来避开Vue.js不能侦测属性被添加的限制。
*	**注意：**target不能是Vue.js实例或者Vue.js实例的根数据对象。

####	4.2.2	Array的处理

###	4.3	vm.$delete
vm.$delete 的作用是删除数据中的某个属性。由于Vue.js的变化侦测是使用Object.defineProperty实现的，所以如果数据是使用delete关键字删除的，那么无法发现数据发生了变化。

####	4.3.1	用法
*	vm.$delete( target, key )
*	
*	参数：
	*	{Object | Array} target
	*	{string | number} propertyName/index

*	**用法：**删除对象属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开Vue.js不能检测到属性被删除的限制，但是你应该很少会使用它。
	*	在2.2.0+中同样支持在数组上工作。
*	**注意：**目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。

####	4.3.2	实现原理
*	vm.$delete方法也是为了解决变化侦测的缺陷。帮助我们在删除属性后自动向依赖发送消息，通知Watcher数据发生了变化。



#	第二篇	虚拟DOM
##	第5章	虚拟DOM简介
###	5.1	什么是虚拟DOM
*	**说明：**事实上，任何应用都有状态，并不是只有使用了现代比较流行的框架之后才有状态。不过现在框架揭露了一个事实，那就是我们的关注点应该聚焦在状态维护上，而DOM操作其实是可以省略掉的，所有才会给我们营造一种错觉，好像只有使用了框架之后应用才会有状态。使用jQuery开发的应用也是有状态的，应用中所使用的变量都是状态。
*	状态可是是JavaScript中的任意类型。Object、Array、String、Number、Boolean等都可以作为状态，这些状态可能最终会以段落、表单、链接或按钮等元素呈现在用户界面上，具体说是呈现在页面上。
*	本质上，我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫作渲染。
*	当某个状态发生变化时，只更新与这个状态相关联的DOM节点。
*	虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。
*	虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。

###	5.2	为什么要引入虚拟DOM

###	5.3	Vue.js中的虚拟DOM
