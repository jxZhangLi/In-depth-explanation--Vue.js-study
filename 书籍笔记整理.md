#	《深入浅出Vue.js》

# 第一篇 变化侦测
* 变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。


##	第2章	Object的变化侦测
Object和Array的变化侦测采用不同的处理方式。

###	2.1	什么是变化侦测
*	Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫**渲染**。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。
*	Vue.js能随意调整粒度，本质上要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

###	2.2 如何追踪变化
*	在JavaScript中，有两种方法可以侦测到变化：使用Object.defineProperty 和 ES6的Proxy。
*	到目前为止，Vue.js还是使用的**Object.defineProperty**来实现的。

###	2.3 如何手机依赖
*	**注意：**在Vue.js2.0中，模板使用数据等同于组件使用数据，所有当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。
*	在getter中手机依赖，在setter中触发依赖。

###	2.4 依赖收集在哪里
*	



##
##	第3章	Array的变化侦测
###	3.1	如何追踪变化
*	我们可以用一个拦截器覆盖Array.prototype。之后，每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后，在拦截器中使用原生Array的原型方法去操作数组。
*	这样通过拦截器，我们就可以追踪到Array的变化。

###	3.2	拦截器
*	Array原型中可以改变数组自身内容的方法有7个，分别是push、pop、shift、unshift、splice、sort和reverse。
	*	push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
	*	pop() 方法用于删除并返回数组的最后一个元素。
	*	shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。
	*	unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
	*	splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。
	*	sort() 方法用于对数组的元素进行排序。
	*	reverse() 方法用于颠倒数组中元素的顺序。

###	3.3	使用拦截器覆盖Array原型

###	3.4	将拦截器方法挂载到数组的属性上

###	3.5	如何收集依赖
*	Array在getter中收集依赖，在拦截器中触发依赖。

###	3.6	依赖列表存在哪儿
*	Vue.js把	Array的依赖存放在Observer中。

###	3.7	收集依赖

###	3.8	在拦截器中获取Observer实例

###	3.9	想数组的依赖发送通知
*	当侦测到数组发生变化时，会向依赖发送通知。


##
##	第4章	变化侦测相关的API实现原理
###	4.1	[vm.$watch](https://cn.vuejs.org/v2/api/#vm-watch)
####	4.1.1	用法
*	vm.$watch( expOrFn, callback, [options] )

*	参数：
	*	{string | Function} expOrFn
	*	{Function | Object} callback
	*	{Object} [options]
		*	{boolean} deep
		*	{boolean} immediate
*	返回值：{Function} unwatch

*	**用法：**用于观察一个表达式或computed（计算属性）函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如 a.b.c 。如果是一个比较复杂的表达式，可以用函数代替表达式。

**注意：**在变异 (不是替换) 对象或数组时，旧值将与新值相同，因
为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。

*	示例：	

*	deep。为了发现对象内部值的变化，可以在选项参数中指定deep:true。
*	注意监听数组的变动不需要这么做。
    `vm.$watch('someObject', callback, {	
		deep:true
	})
	vm.someObject.nestedValue = 123
	//回调函数将被触发`

*	immediate。在选项参数中指定immediate:true，将立即以表达式的当前值触发回调。
	`vm.$watch('a', callback, {
		immediate: true
	})
	//立即以'a'的当前值触发回调`


####	4.1.2	watch的内部原理
*	vm.$watch其实是对Watcher的一种封装。通过Watcher完全可以实现vm.$watch的功能，但是vm.$watch中的参数deep和immediate是Watcher中所没有的。

####	4.1.3	deep参数中的实现原理

###	4.2	[vm.$set](https://cn.vuejs.org/v2/api/#vm-set)
####	4.2.1	用法
*	vm.$set( target, key, value )

*	参数：
	*	{Object | Array} target
	*	{string | number} propertyName/index
	*	{any} value

*	返回值：{Function} unwatch

*	**用法：**在object上设置一个属性，如果object是响应式的，Vue.js会保证属性被创建后也是响应式的，而且触发试图更新。这个方法主要用来避开Vue.js不能侦测属性被添加的限制。
*	**注意：**target不能是Vue.js实例或者Vue.js实例的根数据对象。

####	4.2.2	Array的处理

###	4.3	vm.$delete
vm.$delete 的作用是删除数据中的某个属性。由于Vue.js的变化侦测是使用Object.defineProperty实现的，所以如果数据是使用delete关键字删除的，那么无法发现数据发生了变化。

####	4.3.1	用法
*	vm.$delete( target, key )
*	
*	参数：
	*	{Object | Array} target
	*	{string | number} propertyName/index

*	**用法：**删除对象属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开Vue.js不能检测到属性被删除的限制，但是你应该很少会使用它。
	*	在2.2.0+中同样支持在数组上工作。
*	**注意：**目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。

####	4.3.2	实现原理
*	vm.$delete方法也是为了解决变化侦测的缺陷。帮助我们在删除属性后自动向依赖发送消息，通知Watcher数据发生了变化。



#	第二篇	虚拟DOM
##	第5章	虚拟DOM简介
###	5.1	什么是虚拟DOM
*	**说明：**事实上，任何应用都有状态，并不是只有使用了现代比较流行的框架之后才有状态。不过现在框架揭露了一个事实，那就是我们的关注点应该聚焦在状态维护上，而DOM操作其实是可以省略掉的，所有才会给我们营造一种错觉，好像只有使用了框架之后应用才会有状态。使用jQuery开发的应用也是有状态的，应用中所使用的变量都是状态。
*	状态可是是JavaScript中的任意类型。Object、Array、String、Number、Boolean等都可以作为状态，这些状态可能最终会以段落、表单、链接或按钮等元素呈现在用户界面上，具体说是呈现在页面上。
*	本质上，我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫作渲染。
*	当某个状态发生变化时，只更新与这个状态相关联的DOM节点。
*	虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。
*	虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。

###	5.2	为什么要引入虚拟DOM
*	Vue.js2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个Watcher实例。当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对与渲染。

###	5.3	Vue.js中的虚拟DOM
*	使用模板来描述状态与DOM之间的映射关系。Vue.js通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面。
*	虚拟DOM的终极目标是将虚拟节点（vnode）渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点，会有很多不必要的DOM操作。
*	为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。

##
##	第6章	VNode
###	6.1	什么是VNode
*	DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。
*	vnode只是一个名字，**本质上其实是JavaScript中的一个普通对象**，是从VNode类实例化的对象。
*	简单地说，vnode可以理解成**节点描述对象**，描述了应该怎样去创建真实的DOM节点。
*	我们可以把vnode理解成JavaScript对象版本的DOM元素。

###	6.2	VNode的作用
*	对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。

###	6.3	VNode的类型
*	vnode的类型有以下几种：
	*	注释节点
	*	文本节点
	*	元素节点
	*	组件节点
	*	函数式组件
	*	克隆节点

*	不同类型的vnode之间其实只是属性不同，准确地说是有效属性不同。
####	6.3.1	注释节点
*	注释节点只有两个有效属性——text和isComment，其余属性全是默认的undefined或者false。

####	6.3.2	文本节点
*	当文本类型的vnode被创建时，它只有一个text属性。

####	6.3.3	克隆节点
*	克隆节点是将现有节点的属性复制到新节点中，让新创建的节点和被克隆节点的属性保持一致，从而实现克隆效果。它的作用是优化静态节点和插槽节点（slot node）。
*	克隆节点和被克隆节点之间的唯一区别是isCloned属性，克隆节点的isCloned为true，被克隆的原始节点的isCloned为false。

####	6.3.4	元素节点
*	元素节点通常会存在以下4中有效属性：
	*	**tag**：顾名思义，tag就是一个节点的名称，例如p、ul、li和div等。
	*	**data**：该属性包含了一些节点上的数据，比如attrs、class和style等。
	*	**children**：当前节点的子节点列表。
	*	**context**：它是当前组件的Vue.js实例。

####	6.3.5	组件节点
*	组件节点和元素节点类似，有以下两个独有属性：
	*	**componentOptions**：组件节点的选项参数，其中包含propsData、tag和children。
	*	**componentInstance**：组件的实例，也是Vue.js的实例。事实上，在Vue.js中，每个组件都有一个Vue.js实例。

####	6.3.6	函数式组件
*	函数式组件和组件节点类似，它有两个独有属性 functionalContext和functionalOptions。

###	6.4	总结
*	Vnode是一个类，可以生成不同类型的vnode实例，而不同类型的vnode表示不同类型的真实DOM元素。

##
##	第7章	patch
###	7.1	patch介绍
*	patch的目的其实是修改DOM节点，也可以理解为渲染视图。patch不是暴力替换节点，而是在现有DOM上进行修改来达到渲染视图的目的。对现有DOM进行修改需要做三件事：
	*	创建新增的节点；
	*	删除已经废弃的节点；
	*	修改需要更新的节点。
*	当oldVode和vnode不一样的时候，以vnode为准来渲染视图。

####	7.1.1	新增节点
*	（1）、一个明显的场景就是，当oldVnode不存在时，就需要使用vnode生成真实的DOM元素并将其插入到视图当中去。
*	通常会发生在首次渲染中，因为首次渲染时，DOM中不存在任何节点，所有oldVnode是不存在的。
*	（2）、当vnode和oldVnode完全不是同一个节点的时候，可以得知vnode就是一个全新的节点，而oldVnode就是一个被废弃的节点。

####	7.1.2	删除节点
*	vnode中不存在的节点都是属于被废弃的节点，，而被废弃的节点需要从DOM中删除。

####	7.1.3	更新节点
*	当新旧两个节点是相同的节点时，需要对两个节点进行比较细致的比对，然后对oldVnode在视图中所对应的真实节点进行更新。

###	7.2	创建节点
*	事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点和文本节点。
*	判断vnode是否是元素节点，值需要判断它是否具有tag属性即可。有就认为它是元素节点。
	*	调用当前环境下的createElement方法（浏览器环境下就是document.createElement）插入指定的父节点中。
*	注释节点有一个唯一的标识属性isComment。在所有类型的vnode中，只有注释节点的isComment属性是true。
	*	调用当前环境下creatComment方法（浏览器环境下调用document.createComment）插入指定的父节点中。
*	当发现一个vnode的tag属性不存在时，我们可以用isComment属性来判断它是注释节点还是文本节点。
	*	调用当前环境下的createTextNode方法（浏览器环境下调用document.createTextNode)插入指定的父节点中。

###	7.3	删除节点








#	第三篇	模板编译原理
渲染函数是创建HTML最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份vnode用于虚拟DOM的渲染。所以模板编译其实是配合虚拟DOM进行渲染。
##	第8章	模板编译
模板编译所介绍的内容是如何让虚拟DOM拿到vnode。
###	8.1	概念
*	模板编译的主要目标就是生成渲染函数。渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这个vnode进行渲染。

###	8.2	将模板编译成渲染函数
*	模板编译分三部分内容：
	*	将模板解析为AST（Abstract Syntax Tree，抽象语法树）------解析器
	*	遍历AST标记静态节点（有静态节点标记的不会重新渲染）------优化器
	*	使用AST生成渲染函数------代码生成器

####	8.2.1	解析器
*	过滤器解析器
*	文本解析器
*	HTML解析器