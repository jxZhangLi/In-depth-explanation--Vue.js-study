#	《深入浅出Vue.js》

# 第一篇 变化侦测
* 变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。

#
##	第2章	Object的变化侦测
Object和Array的变化侦测采用不同的处理方式。

###	2.1	什么是变化侦测
*	Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫**渲染**。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。
*	Vue.js能随意调整粒度，本质上要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

###	2.2 如何追踪变化
*	在JavaScript中，有两种方法可以侦测到变化：使用Object.defineProperty 和 ES6的Proxy。
*	到目前为止，Vue.js还是使用的**Object.defineProperty**来实现的。

###	2.3 如何手机依赖
*	**注意：**在Vue.js2.0中，模板使用数据等同于组件使用数据，所有当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。
*	在getter中手机依赖，在setter中触发依赖。

###	2.4 依赖收集在哪里
*	



##
##	第3章	Array的变化侦测
###	3.1	如何追踪变化
*	我们可以用一个拦截器覆盖Array.prototype。之后，每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后，在拦截器中使用原生Array的原型方法去操作数组。
*	这样通过拦截器，我们就可以追踪到Array的变化。

###	3.2	拦截器
*	Array原型中可以改变数组自身内容的方法有7个，分别是push、pop、shift、unshift、splice、sort和reverse。

###	3.3	使用拦截器覆盖Array原型

###	3.4	将拦截器方法挂载到数组的属性上

###	3.5	如何收集依赖
*	Array在getter中收集依赖，在拦截器中触发依赖。

###	3.6	依赖列表存在哪儿
*	Vue.js把	Array的依赖存放在Observer中。

###	3.7	收集依赖

###	3.8	在拦截器中获取Observer实例

###	3.9	想数组的依赖发送通知
*	当侦测到数组发生变化时，会向依赖发送通知。


##
##	第4章	变化侦测相关的API实现原理
###	4.1	[vm.$watch](https://cn.vuejs.org/v2/api/#vm-watch)
####	4.1.1	用法
*	vm.$watch( expOrFn, callback, [options] )

*	参数
	*	{string | Function} expOrFn
	*	{Function | Object} callback
	*	{Object} [options]
		*	{boolean} deep
		*	{boolean} immediate
*	返回值：{Function} unwatch

*	用法：用于观察一个表达式或computed（计算属性）函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如 a.b.c 。如果是一个比较复杂的表达式，可以用函数代替表达式。

**注意：**在变异 (不是替换) 对象或数组时，旧值将与新值相同，因
为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。

*	示例：	

*	deep。为了发现对象内部值的变化，可以在选项参数中指定deep:true。
*	注意监听数组的变动不需要这么做。
    `vm.$watch('someObject', callback, {	
		deep:true
	})
	vm.someObject.nestedValue = 123
	//回调函数将被触发`

*	immediate。在选项参数中指定immediate:true，将立即以表达式的当前值触发回调。
	`vm.$watch('a', callback, {
		immediate: true
	})
	//立即以'a'的当前值触发回调`


####	4.1.2	watch的内部原理
*	vm.$watch其实是对Watcher的一种封装。通过Watcher完全可以实现vm.$watch的功能，但是vm.$watch中的参数deep和immediate是Watcher中所没有的。

####	4.1.3	deep参数中的实现原理
